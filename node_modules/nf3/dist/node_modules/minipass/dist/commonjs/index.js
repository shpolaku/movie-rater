"use strict";var __importDefault=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,`__esModule`,{value:!0}),exports.Minipass=exports.isWritable=exports.isReadable=exports.isStream=void 0;const proc=typeof process==`object`&&process?process:{stdout:null,stderr:null},node_events_1=require(`node:events`),node_stream_1=__importDefault(require(`node:stream`)),node_string_decoder_1=require(`node:string_decoder`),isStream=e=>!!e&&typeof e==`object`&&(e instanceof Minipass||e instanceof node_stream_1.default||(0,exports.isReadable)(e)||(0,exports.isWritable)(e));exports.isStream=isStream;const isReadable=e=>!!e&&typeof e==`object`&&e instanceof node_events_1.EventEmitter&&typeof e.pipe==`function`&&e.pipe!==node_stream_1.default.Writable.prototype.pipe;exports.isReadable=isReadable;const isWritable=e=>!!e&&typeof e==`object`&&e instanceof node_events_1.EventEmitter&&typeof e.write==`function`&&typeof e.end==`function`;exports.isWritable=isWritable;const EOF=Symbol(`EOF`),MAYBE_EMIT_END=Symbol(`maybeEmitEnd`),EMITTED_END=Symbol(`emittedEnd`),EMITTING_END=Symbol(`emittingEnd`),EMITTED_ERROR=Symbol(`emittedError`),CLOSED=Symbol(`closed`),READ=Symbol(`read`),FLUSH=Symbol(`flush`),FLUSHCHUNK=Symbol(`flushChunk`),ENCODING=Symbol(`encoding`),DECODER=Symbol(`decoder`),FLOWING=Symbol(`flowing`),PAUSED=Symbol(`paused`),RESUME=Symbol(`resume`),BUFFER=Symbol(`buffer`),PIPES=Symbol(`pipes`),BUFFERLENGTH=Symbol(`bufferLength`),BUFFERPUSH=Symbol(`bufferPush`),BUFFERSHIFT=Symbol(`bufferShift`),OBJECTMODE=Symbol(`objectMode`),DESTROYED=Symbol(`destroyed`),ERROR=Symbol(`error`),EMITDATA=Symbol(`emitData`),EMITEND=Symbol(`emitEnd`),EMITEND2=Symbol(`emitEnd2`),ASYNC=Symbol(`async`),ABORT=Symbol(`abort`),ABORTED=Symbol(`aborted`),SIGNAL=Symbol(`signal`),DATALISTENERS=Symbol(`dataListeners`),DISCARDED=Symbol(`discarded`),defer=e=>Promise.resolve().then(e),nodefer=e=>e(),isEndish=e=>e===`end`||e===`finish`||e===`prefinish`,isArrayBufferLike=e=>e instanceof ArrayBuffer||!!e&&typeof e==`object`&&e.constructor&&e.constructor.name===`ArrayBuffer`&&e.byteLength>=0,isArrayBufferView=e=>!Buffer.isBuffer(e)&&ArrayBuffer.isView(e);class Pipe{src;dest;opts;ondrain;constructor(e,t,n){this.src=e,this.dest=t,this.opts=n,this.ondrain=()=>e[RESUME](),this.dest.on(`drain`,this.ondrain)}unpipe(){this.dest.removeListener(`drain`,this.ondrain)}proxyErrors(e){}end(){this.unpipe(),this.opts.end&&this.dest.end()}}class PipeProxyErrors extends Pipe{unpipe(){this.src.removeListener(`error`,this.proxyErrors),super.unpipe()}constructor(e,t,n){super(e,t,n),this.proxyErrors=e=>t.emit(`error`,e),e.on(`error`,this.proxyErrors)}}const isObjectModeOptions=e=>!!e.objectMode,isEncodingOptions=e=>!e.objectMode&&!!e.encoding&&e.encoding!==`buffer`;class Minipass extends node_events_1.EventEmitter{[FLOWING]=!1;[PAUSED]=!1;[PIPES]=[];[BUFFER]=[];[OBJECTMODE];[ENCODING];[ASYNC];[DECODER];[EOF]=!1;[EMITTED_END]=!1;[EMITTING_END]=!1;[CLOSED]=!1;[EMITTED_ERROR]=null;[BUFFERLENGTH]=0;[DESTROYED]=!1;[SIGNAL];[ABORTED]=!1;[DATALISTENERS]=0;[DISCARDED]=!1;writable=!0;readable=!0;constructor(...e){let t=e[0]||{};if(super(),t.objectMode&&typeof t.encoding==`string`)throw TypeError(`Encoding and objectMode may not be used together`);isObjectModeOptions(t)?(this[OBJECTMODE]=!0,this[ENCODING]=null):isEncodingOptions(t)?(this[ENCODING]=t.encoding,this[OBJECTMODE]=!1):(this[OBJECTMODE]=!1,this[ENCODING]=null),this[ASYNC]=!!t.async,this[DECODER]=this[ENCODING]?new node_string_decoder_1.StringDecoder(this[ENCODING]):null,t&&t.debugExposeBuffer===!0&&Object.defineProperty(this,`buffer`,{get:()=>this[BUFFER]}),t&&t.debugExposePipes===!0&&Object.defineProperty(this,`pipes`,{get:()=>this[PIPES]});let{signal:n}=t;n&&(this[SIGNAL]=n,n.aborted?this[ABORT]():n.addEventListener(`abort`,()=>this[ABORT]()))}get bufferLength(){return this[BUFFERLENGTH]}get encoding(){return this[ENCODING]}set encoding(e){throw Error(`Encoding must be set at instantiation time`)}setEncoding(e){throw Error(`Encoding must be set at instantiation time`)}get objectMode(){return this[OBJECTMODE]}set objectMode(e){throw Error(`objectMode must be set at instantiation time`)}get async(){return this[ASYNC]}set async(e){this[ASYNC]=this[ASYNC]||!!e}[ABORT](){this[ABORTED]=!0,this.emit(`abort`,this[SIGNAL]?.reason),this.destroy(this[SIGNAL]?.reason)}get aborted(){return this[ABORTED]}set aborted(e){}write(e,t,n){if(this[ABORTED])return!1;if(this[EOF])throw Error(`write after end`);if(this[DESTROYED])return this.emit(`error`,Object.assign(Error(`Cannot call write after a stream was destroyed`),{code:`ERR_STREAM_DESTROYED`})),!0;typeof t==`function`&&(n=t,t=`utf8`),t||=`utf8`;let r=this[ASYNC]?defer:nodefer;if(!this[OBJECTMODE]&&!Buffer.isBuffer(e)){if(isArrayBufferView(e))e=Buffer.from(e.buffer,e.byteOffset,e.byteLength);else if(isArrayBufferLike(e))e=Buffer.from(e);else if(typeof e!=`string`)throw Error(`Non-contiguous data written to non-objectMode stream`)}return this[OBJECTMODE]?(this[FLOWING]&&this[BUFFERLENGTH]!==0&&this[FLUSH](!0),this[FLOWING]?this.emit(`data`,e):this[BUFFERPUSH](e),this[BUFFERLENGTH]!==0&&this.emit(`readable`),n&&r(n),this[FLOWING]):e.length?(typeof e==`string`&&!(t===this[ENCODING]&&!this[DECODER]?.lastNeed)&&(e=Buffer.from(e,t)),Buffer.isBuffer(e)&&this[ENCODING]&&(e=this[DECODER].write(e)),this[FLOWING]&&this[BUFFERLENGTH]!==0&&this[FLUSH](!0),this[FLOWING]?this.emit(`data`,e):this[BUFFERPUSH](e),this[BUFFERLENGTH]!==0&&this.emit(`readable`),n&&r(n),this[FLOWING]):(this[BUFFERLENGTH]!==0&&this.emit(`readable`),n&&r(n),this[FLOWING])}read(e){if(this[DESTROYED])return null;if(this[DISCARDED]=!1,this[BUFFERLENGTH]===0||e===0||e&&e>this[BUFFERLENGTH])return this[MAYBE_EMIT_END](),null;this[OBJECTMODE]&&(e=null),this[BUFFER].length>1&&!this[OBJECTMODE]&&(this[BUFFER]=[this[ENCODING]?this[BUFFER].join(``):Buffer.concat(this[BUFFER],this[BUFFERLENGTH])]);let t=this[READ](e||null,this[BUFFER][0]);return this[MAYBE_EMIT_END](),t}[READ](e,t){if(this[OBJECTMODE])this[BUFFERSHIFT]();else{let n=t;e===n.length||e===null?this[BUFFERSHIFT]():typeof n==`string`?(this[BUFFER][0]=n.slice(e),t=n.slice(0,e),this[BUFFERLENGTH]-=e):(this[BUFFER][0]=n.subarray(e),t=n.subarray(0,e),this[BUFFERLENGTH]-=e)}return this.emit(`data`,t),!this[BUFFER].length&&!this[EOF]&&this.emit(`drain`),t}end(e,t,n){return typeof e==`function`&&(n=e,e=void 0),typeof t==`function`&&(n=t,t=`utf8`),e!==void 0&&this.write(e,t),n&&this.once(`end`,n),this[EOF]=!0,this.writable=!1,(this[FLOWING]||!this[PAUSED])&&this[MAYBE_EMIT_END](),this}[RESUME](){this[DESTROYED]||(!this[DATALISTENERS]&&!this[PIPES].length&&(this[DISCARDED]=!0),this[PAUSED]=!1,this[FLOWING]=!0,this.emit(`resume`),this[BUFFER].length?this[FLUSH]():this[EOF]?this[MAYBE_EMIT_END]():this.emit(`drain`))}resume(){return this[RESUME]()}pause(){this[FLOWING]=!1,this[PAUSED]=!0,this[DISCARDED]=!1}get destroyed(){return this[DESTROYED]}get flowing(){return this[FLOWING]}get paused(){return this[PAUSED]}[BUFFERPUSH](e){this[OBJECTMODE]?this[BUFFERLENGTH]+=1:this[BUFFERLENGTH]+=e.length,this[BUFFER].push(e)}[BUFFERSHIFT](){return this[OBJECTMODE]?--this[BUFFERLENGTH]:this[BUFFERLENGTH]-=this[BUFFER][0].length,this[BUFFER].shift()}[FLUSH](e=!1){do;while(this[FLUSHCHUNK](this[BUFFERSHIFT]())&&this[BUFFER].length);!e&&!this[BUFFER].length&&!this[EOF]&&this.emit(`drain`)}[FLUSHCHUNK](e){return this.emit(`data`,e),this[FLOWING]}pipe(e,n){if(this[DESTROYED])return e;this[DISCARDED]=!1;let r=this[EMITTED_END];return n||={},e===proc.stdout||e===proc.stderr?n.end=!1:n.end=n.end!==!1,n.proxyErrors=!!n.proxyErrors,r?n.end&&e.end():(this[PIPES].push(n.proxyErrors?new PipeProxyErrors(this,e,n):new Pipe(this,e,n)),this[ASYNC]?defer(()=>this[RESUME]()):this[RESUME]()),e}unpipe(e){let t=this[PIPES].find(t=>t.dest===e);t&&(this[PIPES].length===1?(this[FLOWING]&&this[DATALISTENERS]===0&&(this[FLOWING]=!1),this[PIPES]=[]):this[PIPES].splice(this[PIPES].indexOf(t),1),t.unpipe())}addListener(e,t){return this.on(e,t)}on(e,t){let n=super.on(e,t);if(e===`data`)this[DISCARDED]=!1,this[DATALISTENERS]++,!this[PIPES].length&&!this[FLOWING]&&this[RESUME]();else if(e===`readable`&&this[BUFFERLENGTH]!==0)super.emit(`readable`);else if(isEndish(e)&&this[EMITTED_END])super.emit(e),this.removeAllListeners(e);else if(e===`error`&&this[EMITTED_ERROR]){let e=t;this[ASYNC]?defer(()=>e.call(this,this[EMITTED_ERROR])):e.call(this,this[EMITTED_ERROR])}return n}removeListener(e,t){return this.off(e,t)}off(e,t){let n=super.off(e,t);return e===`data`&&(this[DATALISTENERS]=this.listeners(`data`).length,this[DATALISTENERS]===0&&!this[DISCARDED]&&!this[PIPES].length&&(this[FLOWING]=!1)),n}removeAllListeners(e){let t=super.removeAllListeners(e);return(e===`data`||e===void 0)&&(this[DATALISTENERS]=0,!this[DISCARDED]&&!this[PIPES].length&&(this[FLOWING]=!1)),t}get emittedEnd(){return this[EMITTED_END]}[MAYBE_EMIT_END](){!this[EMITTING_END]&&!this[EMITTED_END]&&!this[DESTROYED]&&this[BUFFER].length===0&&this[EOF]&&(this[EMITTING_END]=!0,this.emit(`end`),this.emit(`prefinish`),this.emit(`finish`),this[CLOSED]&&this.emit(`close`),this[EMITTING_END]=!1)}emit(e,...t){let n=t[0];if(e!==`error`&&e!==`close`&&e!==DESTROYED&&this[DESTROYED])return!1;if(e===`data`)return!this[OBJECTMODE]&&!n?!1:this[ASYNC]?(defer(()=>this[EMITDATA](n)),!0):this[EMITDATA](n);if(e===`end`)return this[EMITEND]();if(e===`close`){if(this[CLOSED]=!0,!this[EMITTED_END]&&!this[DESTROYED])return!1;let e=super.emit(`close`);return this.removeAllListeners(`close`),e}else if(e===`error`){this[EMITTED_ERROR]=n,super.emit(ERROR,n);let e=!this[SIGNAL]||this.listeners(`error`).length?super.emit(`error`,n):!1;return this[MAYBE_EMIT_END](),e}else if(e===`resume`){let e=super.emit(`resume`);return this[MAYBE_EMIT_END](),e}else if(e===`finish`||e===`prefinish`){let t=super.emit(e);return this.removeAllListeners(e),t}let r=super.emit(e,...t);return this[MAYBE_EMIT_END](),r}[EMITDATA](e){for(let t of this[PIPES])t.dest.write(e)===!1&&this.pause();let t=this[DISCARDED]?!1:super.emit(`data`,e);return this[MAYBE_EMIT_END](),t}[EMITEND](){return this[EMITTED_END]?!1:(this[EMITTED_END]=!0,this.readable=!1,this[ASYNC]?(defer(()=>this[EMITEND2]()),!0):this[EMITEND2]())}[EMITEND2](){if(this[DECODER]){let e=this[DECODER].end();if(e){for(let t of this[PIPES])t.dest.write(e);this[DISCARDED]||super.emit(`data`,e)}}for(let e of this[PIPES])e.end();let e=super.emit(`end`);return this.removeAllListeners(`end`),e}async collect(){let e=Object.assign([],{dataLength:0});this[OBJECTMODE]||(e.dataLength=0);let t=this.promise();return this.on(`data`,t=>{e.push(t),this[OBJECTMODE]||(e.dataLength+=t.length)}),await t,e}async concat(){if(this[OBJECTMODE])throw Error(`cannot concat in objectMode`);let e=await this.collect();return this[ENCODING]?e.join(``):Buffer.concat(e,e.dataLength)}async promise(){return new Promise((e,t)=>{this.on(DESTROYED,()=>t(Error(`stream destroyed`))),this.on(`error`,e=>t(e)),this.on(`end`,()=>e())})}[Symbol.asyncIterator](){this[DISCARDED]=!1;let e=!1,t=async()=>(this.pause(),e=!0,{value:void 0,done:!0});return{next:()=>{if(e)return t();let n=this.read();if(n!==null)return Promise.resolve({done:!1,value:n});if(this[EOF])return t();let r,i,a=e=>{this.off(`data`,o),this.off(`end`,s),this.off(DESTROYED,c),t(),i(e)},o=e=>{this.off(`error`,a),this.off(`end`,s),this.off(DESTROYED,c),this.pause(),r({value:e,done:!!this[EOF]})},s=()=>{this.off(`error`,a),this.off(`data`,o),this.off(DESTROYED,c),t(),r({done:!0,value:void 0})},c=()=>a(Error(`stream destroyed`));return new Promise((e,t)=>{i=t,r=e,this.once(DESTROYED,c),this.once(`error`,a),this.once(`end`,s),this.once(`data`,o)})},throw:t,return:t,[Symbol.asyncIterator](){return this}}}[Symbol.iterator](){this[DISCARDED]=!1;let e=!1,t=()=>(this.pause(),this.off(ERROR,t),this.off(DESTROYED,t),this.off(`end`,t),e=!0,{done:!0,value:void 0});return this.once(`end`,t),this.once(ERROR,t),this.once(DESTROYED,t),{next:()=>{if(e)return t();let n=this.read();return n===null?t():{done:!1,value:n}},throw:t,return:t,[Symbol.iterator](){return this}}}destroy(e){if(this[DESTROYED])return e?this.emit(`error`,e):this.emit(DESTROYED),this;this[DESTROYED]=!0,this[DISCARDED]=!0,this[BUFFER].length=0,this[BUFFERLENGTH]=0;let t=this;return typeof t.close==`function`&&!this[CLOSED]&&t.close(),e?this.emit(`error`,e):this.emit(DESTROYED),this}static get isStream(){return exports.isStream}}exports.Minipass=Minipass;