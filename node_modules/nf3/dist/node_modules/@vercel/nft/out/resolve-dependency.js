"use strict";Object.defineProperty(exports,`__esModule`,{value:!0}),exports.NotFoundError=void 0,exports.default=resolveDependency;const path_1=require(`path`),module_1=require(`module`),node_version_1=require(`./utils/node-version`);async function resolveDependency(t,n,r,a=!0){let o;if((0,path_1.isAbsolute)(t)||t===`.`||t===`..`||t.startsWith(`./`)||t.startsWith(`../`)){let a=t.endsWith(`/`);o=await resolvePath((0,path_1.resolve)(n,`..`,t)+(a?`/`:``),n,r)}else o=t[0]===`#`?await packageImportsResolve(t,n,r,a):await resolvePackage(t,n,r,a);return Array.isArray(o)?Promise.all(o.map(e=>r.realpath(e,n))):o.startsWith(`node:`)?o:r.realpath(o,n)}async function resolvePath(e,t,n){let r=await resolveFile(e,t,n)||await resolveDir(e,t,n);if(!r)throw new NotFoundError(e,t);return r}async function resolveFile(t,n,r){if(!t.endsWith(`/`)){if(t=await r.realpath(t,n),await r.isFile(t))return t;if(r.ts&&t.startsWith(r.base)&&t.slice(r.base.length).indexOf(path_1.sep+`node_modules`+path_1.sep)===-1&&await r.isFile(t+`.ts`))return t+`.ts`;if(r.ts&&t.startsWith(r.base)&&t.slice(r.base.length).indexOf(path_1.sep+`node_modules`+path_1.sep)===-1&&await r.isFile(t+`.tsx`))return t+`.tsx`;if(await r.isFile(t+`.js`))return t+`.js`;if(await r.isFile(t+`.json`))return t+`.json`;if(await r.isFile(t+`.node`))return t+`.node`}}async function resolveDir(t,n,r){if(t.endsWith(`/`)&&(t=t.slice(0,-1)),!await r.isDir(t))return;let i=await getPkgCfg(t,r);if(i&&typeof i.main==`string`){let o=await resolveFile((0,path_1.resolve)(t,i.main),n,r)||await resolveFile((0,path_1.resolve)(t,i.main,`index`),n,r);if(o)return await r.emitFile(t+path_1.sep+`package.json`,`resolve`,n),o}return resolveFile((0,path_1.resolve)(t,`index`),n,r)}class NotFoundError extends Error{code;constructor(e,t){super(`Cannot find module '`+e+`' loaded from `+t),this.code=`MODULE_NOT_FOUND`}}exports.NotFoundError=NotFoundError;const nodeBuiltins=new Set(module_1.builtinModules);function getPkgName(e){let t=e.split(`/`);return e[0]===`@`&&t.length>1?t.length>1?t.slice(0,2).join(`/`):null:t.length?t[0]:null}async function getPkgCfg(t,n){let r=await n.readFile(t+path_1.sep+`package.json`);if(r)try{return JSON.parse(r.toString())}catch{}}function getExportsTarget(e,t,r){if(typeof e==`string`||e===null)return e;if(Array.isArray(e))for(let n of e){let e=getExportsTarget(n,t,r);if(e===null||typeof e==`string`&&e.startsWith(`./`))return e}else if(typeof e==`object`){for(let i of Object.keys(e))if(i===`default`||i===`require`&&r||i===`import`&&!r||i===`module-sync`&&(0,node_version_1.getNodeMajorVersion)()>=22||t.includes(i)){let n=getExportsTarget(e[i],t,r);if(n!==void 0)return n}}}async function validateAndResolvePaths(e,t,n,r){let i=[];for(let c of e)if(r){let e=await resolveFile(c,t,n)||await resolveDir(c,t,n);if(!e)throw new NotFoundError(c,t);i.push(e)}else{if(!await n.isFile(c))throw new NotFoundError(c,t);i.push(c)}return i}async function resolveExportsImports(e,t,r,i,a,o,s){let c;if(a){if(!(typeof t==`object`&&!Array.isArray(t)&&t!==null))return;c=t}else c=typeof t==`string`||Array.isArray(t)||t===null||typeof t==`object`&&Object.keys(t).length&&Object.keys(t)[0][0]!==`.`?{".":t}:t;if(r in c){let t=getExportsTarget(c[r],i.conditions,o);if(typeof t==`string`&&t.startsWith(`./`)){let a=e+t.slice(1),l=[a],u=c[r];if(typeof u==`object`&&u&&!Array.isArray(u)&&`module-sync`in u&&(0,node_version_1.getNodeMajorVersion)()>=22){let t=getExportsTarget(u[`require`in u?`require`:`default`],i.conditions,o);if(typeof t==`string`&&t.startsWith(`./`)){let n=e+t.slice(1);n!==a&&l.push(n)}}return await validateAndResolvePaths(l,s,i,o)}}for(let t of Object.keys(c).sort((e,t)=>t.length-e.length)){if(t.endsWith(`*`)&&r.startsWith(t.slice(0,-1))){let n=getExportsTarget(c[t],i.conditions,o);if(typeof n==`string`&&n.startsWith(`./`))return await validateAndResolvePaths([e+n.slice(1).replace(/\*/g,r.slice(t.length-1))],s,i,o)}if(t.endsWith(`/`)&&r.startsWith(t)){let n=getExportsTarget(c[t],i.conditions,o);if(typeof n==`string`&&n.endsWith(`/`)&&n.startsWith(`./`))return await validateAndResolvePaths([e+n.slice(1)+r.slice(t.length)],s,i,o)}}}async function resolveRemappings(t,n,r,i){if(i.conditions?.includes(`browser`)){let{browser:o}=n;if(!o)return;if(typeof o==`object`)for(let[n,s]of Object.entries(o)){if(typeof s!=`string`||!n.startsWith(`./`)||!s.startsWith(`./`))continue;let o=await resolveFile(t+path_1.sep+n,r,i),c=await resolveFile(t+path_1.sep+s,r,i);o&&c&&i.addRemapping(o,c)}}}async function packageImportsResolve(t,n,r,i){if(t!==`#`&&!t.startsWith(`#/`)&&r.conditions){let a=await r.getPjsonBoundary(n);if(a){let o=await getPkgCfg(a,r),{imports:s}=o||{};if(o&&s!=null){let o=await resolveExportsImports(a,s,t,r,!0,i,n);if(o)return await r.emitFile(a+path_1.sep+`package.json`,`resolve`,n),o}}}throw new NotFoundError(t,n)}async function resolvePackage(t,n,r,i){let d=n;if(nodeBuiltins.has(t))return`node:`+t;if(t.startsWith(`node:`))return t;let f=getPkgName(t)||``,p;if(r.conditions){let a=await r.getPjsonBoundary(n);if(a){let o=await getPkgCfg(a,r),{exports:s}=o||{};o&&o.name&&o.name===f&&s!=null&&(p=await resolveExportsImports(a,s,`.`+t.slice(f.length),r,!1,i,n),p&&await r.emitFile(a+path_1.sep+`package.json`,`resolve`,n))}}let m,h=d.indexOf(path_1.sep);for(;(m=d.lastIndexOf(path_1.sep))>h;){d=d.slice(0,m);let s=d+path_1.sep+`node_modules`,c=await r.stat(s);if(!c||!c.isDirectory())continue;let l=await getPkgCfg(s+path_1.sep+f,r),{exports:h}=l||{};if(l&&await resolveRemappings(s+path_1.sep+f,l,n,r),r.conditions&&h!=null&&!p){let c;r.exportsOnly||(c=await resolveFile(s+path_1.sep+t,n,r)||await resolveDir(s+path_1.sep+t,n,r));let l=await resolveExportsImports(s+path_1.sep+f,h,`.`+t.slice(f.length),r,!1,i,n);if(l)return await r.emitFile(s+path_1.sep+f+path_1.sep+`package.json`,`resolve`,n),c&&!l.includes(c)?[...l,c]:l;if(c)return c}else{let i=await resolveFile(s+path_1.sep+t,n,r)||await resolveDir(s+path_1.sep+t,n,r);if(i){if(p){if(Array.isArray(p))return p.includes(i)?p:[i,...p];if(p!==i)return[i,p]}return i}}}if(p)return p;if(Object.hasOwnProperty.call(r.paths,t))return r.paths[t];for(let e of Object.keys(r.paths))if(e.endsWith(`/`)&&t.startsWith(e)){let i=r.paths[e]+t.slice(e.length),c=await resolveFile(i,n,r)||await resolveDir(i,n,r);if(!c)throw new NotFoundError(t,n);return c}throw new NotFoundError(t,n)}