"use strict";Object.defineProperty(exports,`__esModule`,{value:!0});var path=require(`path`),estreeWalker=require(`estree-walker`),pm=require(`picomatch`);const addExtension=function(t,n=`.js`){let r=`${t}`;return path.extname(t)||(r+=n),r},extractors={ArrayPattern(e,t){for(let n of t.elements)n&&extractors[n.type](e,n)},AssignmentPattern(e,t){extractors[t.left.type](e,t.left)},Identifier(e,t){e.push(t.name)},MemberExpression(){},ObjectPattern(e,t){for(let n of t.properties)n.type===`RestElement`?extractors.RestElement(e,n):extractors[n.value.type](e,n.value)},RestElement(e,t){extractors[t.argument.type](e,t.argument)}},extractAssignedNames=function(e){let t=[];return extractors[e.type](t,e),t},blockDeclarations={const:!0,let:!0};class Scope{constructor(e={}){this.parent=e.parent,this.isBlockScope=!!e.block,this.declarations=Object.create(null),e.params&&e.params.forEach(e=>{extractAssignedNames(e).forEach(e=>{this.declarations[e]=!0})})}addDeclaration(e,t,n){!t&&this.isBlockScope?this.parent.addDeclaration(e,t,n):e.id&&extractAssignedNames(e.id).forEach(e=>{this.declarations[e]=!0})}contains(e){return this.declarations[e]||(this.parent?this.parent.contains(e):!1)}}const attachScopes=function(e,n=`scope`){let r=new Scope;return estreeWalker.walk(e,{enter(e,t){let i=e;if(/(?:Function|Class)Declaration/.test(i.type)&&r.addDeclaration(i,!1,!1),i.type===`VariableDeclaration`){let{kind:e}=i,t=blockDeclarations[e];i.declarations.forEach(e=>{r.addDeclaration(e,t,!0)})}let a;if(i.type.includes(`Function`)){let e=i;a=new Scope({parent:r,block:!1,params:e.params}),e.type===`FunctionExpression`&&e.id&&a.addDeclaration(e,!1,!1)}/For(?:In|Of)?Statement/.test(i.type)&&(a=new Scope({parent:r,block:!0})),i.type===`BlockStatement`&&!t.type.includes(`Function`)&&(a=new Scope({parent:r,block:!0})),i.type===`CatchClause`&&(a=new Scope({parent:r,params:i.param?[i.param]:[],block:!0})),a&&(Object.defineProperty(i,n,{value:a,configurable:!0}),r=a)},leave(e){e[n]&&(r=r.parent)}}),r};function isArray(e){return Array.isArray(e)}function ensureArray(e){return isArray(e)?e:e==null?[]:[e]}const normalizePathRegExp=RegExp(`\\${path.win32.sep}`,`g`),normalizePath=function(t){return t.replace(normalizePathRegExp,path.posix.sep)};function getMatcherString(t,n){if(n===!1||path.isAbsolute(t)||t.startsWith(`**`))return normalizePath(t);let r=normalizePath(path.resolve(n||``)).replace(/[-^$*+?.()|[\]{}]/g,`\\$&`);return path.posix.join(r,normalizePath(t))}const createFilter=function(e,t,r){let i=r&&r.resolve,a=e=>e instanceof RegExp?e:{test:t=>pm(getMatcherString(e,i),{dot:!0})(t)},o=ensureArray(e).map(a),s=ensureArray(t).map(a);return!o.length&&!s.length?e=>typeof e==`string`&&!e.includes(`\0`):function(e){if(typeof e!=`string`||e.includes(`\0`))return!1;let t=normalizePath(e);for(let e=0;e<s.length;++e){let n=s[e];if(n instanceof RegExp&&(n.lastIndex=0),n.test(t))return!1}for(let e=0;e<o.length;++e){let n=o[e];if(n instanceof RegExp&&(n.lastIndex=0),n.test(t))return!0}return!o.length}},reservedWords=`break case class catch const continue debugger default delete do else export extends finally for function if import in instanceof let new return super switch this throw try typeof var void while with yield enum await implements package protected static interface private public`,builtins=`arguments Infinity NaN undefined null true false eval uneval isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent encodeURI encodeURIComponent escape unescape Object Function Boolean Symbol Error EvalError InternalError RangeError ReferenceError SyntaxError TypeError URIError Number Math Date String RegExp Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array Map Set WeakMap WeakSet SIMD ArrayBuffer DataView JSON Promise Generator GeneratorFunction Reflect Proxy Intl`,forbiddenIdentifiers=new Set(`break case class catch const continue debugger default delete do else export extends finally for function if import in instanceof let new return super switch this throw try typeof var void while with yield enum await implements package protected static interface private public arguments Infinity NaN undefined null true false eval uneval isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent encodeURI encodeURIComponent escape unescape Object Function Boolean Symbol Error EvalError InternalError RangeError ReferenceError SyntaxError TypeError URIError Number Math Date String RegExp Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array Map Set WeakMap WeakSet SIMD ArrayBuffer DataView JSON Promise Generator GeneratorFunction Reflect Proxy Intl`.split(` `));forbiddenIdentifiers.add(``);const makeLegalIdentifier=function(e){let t=e.replace(/-(\w)/g,(e,t)=>t.toUpperCase()).replace(/[^$_a-zA-Z0-9]/g,`_`);return(/\d/.test(t[0])||forbiddenIdentifiers.has(t))&&(t=`_${t}`),t||`_`};function stringify(e){return(JSON.stringify(e)||`undefined`).replace(/[\u2028\u2029]/g,e=>`\\u${`000${e.charCodeAt(0).toString(16)}`.slice(-4)}`)}function serializeArray(e,t,n){let r=`[`,i=t?`\n${n}${t}`:``;for(let a=0;a<e.length;a++){let o=e[a];r+=`${a>0?`,`:``}${i}${serialize(o,t,n+t)}`}return`${r}${t?`\n${n}`:``}]`}function serializeObject(e,t,n){let r=`{`,i=t?`\n${n}${t}`:``,a=Object.entries(e);for(let e=0;e<a.length;e++){let[o,s]=a[e],c=makeLegalIdentifier(o)===o?o:stringify(o);r+=`${e>0?`,`:``}${i}${c}:${t?` `:``}${serialize(s,t,n+t)}`}return`${r}${t?`\n${n}`:``}}`}function serialize(e,t,n){if(typeof e==`object`&&e)return Array.isArray(e)?serializeArray(e,t,n):e instanceof Date?`new Date(${e.getTime()})`:e instanceof RegExp?e.toString():serializeObject(e,t,n);if(typeof e==`number`){if(e===1/0)return`Infinity`;if(e===-1/0)return`-Infinity`;if(e===0)return 1/e==1/0?`0`:`-0`;if(e!==e)return`NaN`}if(typeof e==`symbol`){let t=Symbol.keyFor(e);if(t!==void 0)return`Symbol.for(${stringify(t)})`}return typeof e==`bigint`?`${e}n`:stringify(e)}const hasStringIsWellFormed=`isWellFormed`in String.prototype;function isWellFormedString(e){return hasStringIsWellFormed?e.isWellFormed():!/\p{Surrogate}/u.test(e)}const dataToEsm=function(e,t={}){let n=t.compact?``:`indent`in t?t.indent:`	`,r=t.compact?``:` `,i=t.compact?``:`
`,a=t.preferConst?`const`:`var`;if(t.namedExports===!1||typeof e!=`object`||Array.isArray(e)||e instanceof Date||e instanceof RegExp||e===null){let i=serialize(e,t.compact?null:n,``);return`export default${r||(/^[{[\-\/]/.test(i)?``:` `)}${i};`}let o=0;for(let t of Object.keys(e)){let e=/^(_+)/.exec(t)?.[0].length??0;e>o&&(o=e)}let s=`${`_`.repeat(o+1)}arbitrary`,c=``,l=[],u=[];for(let[o,d]of Object.entries(e))if(o===makeLegalIdentifier(o))t.objectShorthand?l.push(o):l.push(`${o}:${r}${o}`),c+=`export ${a} ${o}${r}=${r}${serialize(d,t.compact?null:n,``)};${i}`;else if(l.push(`${stringify(o)}:${r}${serialize(d,t.compact?null:n,``)}`),t.includeArbitraryNames&&isWellFormedString(o)){let e=`${s}${u.length}`;c+=`${a} ${e}${r}=${r}${serialize(d,t.compact?null:n,``)};${i}`,u.push(`${e} as ${JSON.stringify(o)}`)}let d=u.length>0?`export${r}{${i}${n}${u.join(`,${i}${n}`)}${i}};${i}`:``,f=`export default${r}{${i}${n}${l.join(`,${i}${n}`)}${i}};${i}`;return`${c}${d}${f}`};function exactRegex(e,t){return RegExp(`^${combineMultipleStrings(e)}$`,t)}function prefixRegex(e,t){return RegExp(`^${combineMultipleStrings(e)}`,t)}function suffixRegex(e,t){return RegExp(`${combineMultipleStrings(e)}$`,t)}const escapeRegexRE=/[-/\\^$*+?.()|[\]{}]/g;function escapeRegex(e){return e.replace(escapeRegexRE,`\\$&`)}function combineMultipleStrings(e){if(Array.isArray(e)){let t=e.map(escapeRegex).join(`|`);return t&&e.length>1?`(?:${t})`:t}return escapeRegex(e)}var index={addExtension,attachScopes,createFilter,dataToEsm,exactRegex,extractAssignedNames,makeLegalIdentifier,normalizePath,prefixRegex,suffixRegex};exports.addExtension=addExtension,exports.attachScopes=attachScopes,exports.createFilter=createFilter,exports.dataToEsm=dataToEsm,exports.default=index,exports.exactRegex=exactRegex,exports.extractAssignedNames=extractAssignedNames,exports.makeLegalIdentifier=makeLegalIdentifier,exports.normalizePath=normalizePath,exports.prefixRegex=prefixRegex,exports.suffixRegex=suffixRegex,module.exports=Object.assign(exports.default,exports);