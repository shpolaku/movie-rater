"use strict";module.exports=exports=install,exports.usage=`Attempts to install pre-built binary for module`;const fs=require(`fs`),path=require(`path`),log=require(`./util/log.js`),existsAsync=fs.exists||path.exists,versioning=require(`./util/versioning.js`),napi=require(`./util/napi.js`),s3_setup=require(`./util/s3_setup.js`),url=require(`url`),fetch=require(`node-fetch`),tar=require(`tar`);let npgVersion=`unknown`;try{let n=fs.readFileSync(path.join(__dirname,`..`,`package.json`),`utf8`);npgVersion=JSON.parse(n).version}catch{}function place_binary_authenticated(e,t,r){if(log.info(`install`,`Attempting authenticated S3 download`),!process.env.AWS_ACCESS_KEY_ID||!process.env.AWS_SECRET_ACCESS_KEY){let e=Error(`Binary is private but AWS credentials not found. Please configure AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY environment variables, or use --fallback-to-build to compile from source.`);return e.statusCode=403,r(e)}try{let i=s3_setup.detect(e),a=s3_setup.get_s3(i),c=url.resolve(i.prefix,e.package_name);log.info(`install`,`Downloading from S3:`,i.bucket,c);let l={Bucket:i.bucket,Key:c};a.getObject(l,(e,i)=>{if(e)return log.error(`install`,`Authenticated S3 download failed:`,e.message),r(e);log.info(`install`,`Authenticated download successful, extracting...`);let{Readable:a}=require(`stream`),o=a.from(i.Body),s=0;o.pipe(extract(t,e=>{s+=1,log.info(`install`,`unpacking ${e.path}`)})).on(`error`,e=>{r(e)}).on(`close`,()=>{log.info(`install`,`extracted file count: ${s}`),r()})})}catch(e){if(e.code===`MODULE_NOT_FOUND`&&e.message.includes(`aws-sdk`)){let e=Error(`Binary is private and requires aws-sdk for authenticated download. Please run: npm install aws-sdk`);return e.statusCode=403,r(e)}log.error(`install`,`Error setting up authenticated download:`,e.message),r(e)}}function place_binary(t,r,i,a){log.log(`GET`,t);let o=process.env.npm_config_user_agent||`node `+process.version,s=t.replace(`+`,`%2B`),l={uri:s,headers:{"User-Agent":`node-pre-gyp (v`+npgVersion+`, `+o+`)`},follow_max:10};if(i.cafile)try{l.ca=fs.readFileSync(i.cafile)}catch(e){return a(e)}else i.ca&&(l.ca=i.ca);let f=i.proxy||process.env.http_proxy||process.env.HTTP_PROXY||process.env.npm_config_proxy,m;if(f){let{HttpsProxyAgent:e}=require(`https-proxy-agent`);m=new e(f),log.log(`download`,`proxy agent configured using: "${f}"`)}fetch(s,{agent:m}).then(e=>{if(!e.ok){if(e.status===403)return log.info(`install`,`Received 403 Forbidden - attempting authenticated download`),place_binary_authenticated(i,r,a),{authenticated:!0};throw Error(`response status ${e.status} ${e.statusText} on ${s}`)}let t=e.body;return new Promise((e,i)=>{let a=0;t.pipe(extract(r,e=>{a+=1,log.info(`install`,`unpacking ${e.path}`)})).on(`error`,e=>{i(e)}),t.on(`end`,()=>{e(`extracted file count: ${a}`)}),t.on(`error`,e=>{i(e)})})}).then(e=>{e&&e.authenticated||(log.info(e),a())}).catch(e=>{log.error(`install ${e.message}`),a(e)})}function extract(e,t){return tar.extract({cwd:e,strip:1,onentry:t})}function extract_from_local(t,r,i){if(!fs.existsSync(t))return i(Error(`Cannot find file `+t));log.info(`Found local file to extract from `+t);let a=0;function o(e){a+=1,log.info(`install`,`unpacking `+e.path)}function s(e){if(e)return i(e);if(a===0)return i(Error(`There was a fatal problem while extracting the tarball`));log.info(`tarball`,`done parsing tarball`),i()}fs.createReadStream(t).pipe(extract(r,o)).on(`close`,s).on(`error`,s)}function do_build(e,t,n){let r=[`rebuild`].concat(t);e.todo.push({name:`build`,args:r}),process.nextTick(n)}function print_fallback_error(e,t,r){let i=` (falling back to source compile with node-gyp)`,a=``;e.statusCode===void 0?(a=`Pre-built binaries not installable for `+r.name+`@`+r.version,a+=` and `+t.runtime+`@`+(t.target||process.versions.node)+` (`+t.node_abi+` ABI, `+t.libc+`)`,a+=i,log.warn(a),log.warn(`Hit error `+e.message)):(a=`Pre-built binaries not found for `+r.name+`@`+r.version,a+=` and `+t.runtime+`@`+(t.target||process.versions.node)+` (`+t.node_abi+` ABI, `+t.libc+`)`,a+=i,log.warn(`Tried to download(`+e.statusCode+`): `+t.hosted_tarball),log.warn(a),log.error(e.message))}function install(o,s,c){let l=o.package_json,u=napi.get_napi_build_version_from_command_args(s),d=o.opts[`build-from-source`]||o.opts.build_from_source,p=o.opts[`update-binary`]||o.opts.update_binary;if(d===l.name||d===!0||d===`true`)return log.info(`build`,`requesting source compile`),do_build(o,s,c);{let a=o.opts[`fallback-to-build`]||o.opts.fallback_to_build,d=a===l.name||a===!0||a===`true`;if(process.env.npm_config_argv){let e=JSON.parse(process.env.npm_config_argv).cooked,t=e.indexOf(`--fallback-to-build`);t>-1&&e.length>t&&e[t+1]===`false`&&(d=!1,log.info(`install`,`Build fallback disabled via npm flag: --fallback-to-build=false`))}let h;try{h=versioning.evaluate(l,o.opts,u)}catch(e){return c(e)}h.ca=o.opts.ca,h.cafile=o.opts.cafile;let g=h.hosted_tarball,_=h.module_path,v=path.join(_,h.module_name+`.node`);existsAsync(v,t=>{if(!p){if(t)return console.log(`[`+l.name+`] Success: "`+v+`" already installed`),console.log(`Pass --update-binary to reinstall or --build-from-source to recompile`),c();log.info(`check`,`checked for "`+v+`" (not found)`)}fs.promises.mkdir(_,{recursive:!0}).then(()=>{let e=g.startsWith(`file://`)&&g.slice(7);e?extract_from_local(e,_,r):place_binary(g,_,h,r)}).catch(e=>{r(e)});function r(e){return e&&d?(print_fallback_error(e,h,l),do_build(o,s,c)):e?c(e):(console.log(`[`+l.name+`] Success: "`+v+`" is installed via remote`),c())}})}}process.env.node_pre_gyp_mock_s3&&require(`./mock/http`)();