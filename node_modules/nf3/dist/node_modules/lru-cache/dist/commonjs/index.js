"use strict";Object.defineProperty(exports,`__esModule`,{value:!0}),exports.LRUCache=void 0;const defaultPerf=typeof performance==`object`&&performance&&typeof performance.now==`function`?performance:Date,warned=new Set,PROCESS=typeof process==`object`&&process?process:{},emitWarning=(e,t,r,i)=>{typeof PROCESS.emitWarning==`function`?PROCESS.emitWarning(e,t,r,i):console.error(`[${r}] ${t}: ${e}`)};let AC=globalThis.AbortController,AS=globalThis.AbortSignal;if(AC===void 0){AS=class{onabort;_onabort=[];reason;aborted=!1;addEventListener(e,t){this._onabort.push(t)}},AC=class{constructor(){t()}signal=new AS;abort(e){if(!this.signal.aborted){this.signal.reason=e,this.signal.aborted=!0;for(let t of this.signal._onabort)t(e);this.signal.onabort?.(e)}}};let e=PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING!==`1`,t=()=>{e&&(e=!1,emitWarning("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.",`NO_ABORT_CONTROLLER`,`ENOTSUP`,t))}}const shouldWarn=e=>!warned.has(e),TYPE=Symbol(`type`),isPosInt=e=>e&&e===Math.floor(e)&&e>0&&isFinite(e),getUintArray=e=>isPosInt(e)?e<=2**8?Uint8Array:e<=2**16?Uint16Array:e<=2**32?Uint32Array:e<=2**53-1?ZeroArray:null:null;class ZeroArray extends Array{constructor(e){super(e),this.fill(0)}}class Stack{heap;length;static#constructing=!1;static create(e){let t=getUintArray(e);if(!t)return[];Stack.#constructing=!0;let n=new Stack(e,t);return Stack.#constructing=!1,n}constructor(e,t){if(!Stack.#constructing)throw TypeError(`instantiate Stack using Stack.create(n)`);this.heap=new t(e),this.length=0}push(e){this.heap[this.length++]=e}pop(){return this.heap[--this.length]}}class LRUCache{#max;#maxSize;#dispose;#onInsert;#disposeAfter;#fetchMethod;#memoMethod;#perf;get perf(){return this.#perf}ttl;ttlResolution;ttlAutopurge;updateAgeOnGet;updateAgeOnHas;allowStale;noDisposeOnSet;noUpdateTTL;maxEntrySize;sizeCalculation;noDeleteOnFetchRejection;noDeleteOnStaleGet;allowStaleOnFetchAbort;allowStaleOnFetchRejection;ignoreFetchAbort;#size;#calculatedSize;#keyMap;#keyList;#valList;#next;#prev;#head;#tail;#free;#disposed;#sizes;#starts;#ttls;#autopurgeTimers;#hasDispose;#hasFetchMethod;#hasDisposeAfter;#hasOnInsert;static unsafeExposeInternals(e){return{starts:e.#starts,ttls:e.#ttls,autopurgeTimers:e.#autopurgeTimers,sizes:e.#sizes,keyMap:e.#keyMap,keyList:e.#keyList,valList:e.#valList,next:e.#next,prev:e.#prev,get head(){return e.#head},get tail(){return e.#tail},free:e.#free,isBackgroundFetch:t=>e.#isBackgroundFetch(t),backgroundFetch:(t,n,r,i)=>e.#backgroundFetch(t,n,r,i),moveToTail:t=>e.#moveToTail(t),indexes:t=>e.#indexes(t),rindexes:t=>e.#rindexes(t),isStale:t=>e.#isStale(t)}}get max(){return this.#max}get maxSize(){return this.#maxSize}get calculatedSize(){return this.#calculatedSize}get size(){return this.#size}get fetchMethod(){return this.#fetchMethod}get memoMethod(){return this.#memoMethod}get dispose(){return this.#dispose}get onInsert(){return this.#onInsert}get disposeAfter(){return this.#disposeAfter}constructor(n){let{max:i=0,ttl:a,ttlResolution:s=1,ttlAutopurge:u,updateAgeOnGet:p,updateAgeOnHas:m,allowStale:h,dispose:g,onInsert:_,disposeAfter:v,noDisposeOnSet:y,noUpdateTTL:b,maxSize:x=0,maxEntrySize:S=0,sizeCalculation:C,fetchMethod:w,memoMethod:T,noDeleteOnFetchRejection:E,noDeleteOnStaleGet:D,allowStaleOnFetchRejection:O,allowStaleOnFetchAbort:k,ignoreFetchAbort:A,perf:j}=n;if(j!==void 0&&typeof j?.now!=`function`)throw TypeError(`perf option must have a now() method if specified`);if(this.#perf=j??defaultPerf,i!==0&&!isPosInt(i))throw TypeError(`max option must be a nonnegative integer`);let M=i?getUintArray(i):Array;if(!M)throw Error(`invalid max value: `+i);if(this.#max=i,this.#maxSize=x,this.maxEntrySize=S||this.#maxSize,this.sizeCalculation=C,this.sizeCalculation){if(!this.#maxSize&&!this.maxEntrySize)throw TypeError(`cannot set sizeCalculation without setting maxSize or maxEntrySize`);if(typeof this.sizeCalculation!=`function`)throw TypeError(`sizeCalculation set to non-function`)}if(T!==void 0&&typeof T!=`function`)throw TypeError(`memoMethod must be a function if defined`);if(this.#memoMethod=T,w!==void 0&&typeof w!=`function`)throw TypeError(`fetchMethod must be a function if specified`);if(this.#fetchMethod=w,this.#hasFetchMethod=!!w,this.#keyMap=new Map,this.#keyList=Array(i).fill(void 0),this.#valList=Array(i).fill(void 0),this.#next=new M(i),this.#prev=new M(i),this.#head=0,this.#tail=0,this.#free=Stack.create(i),this.#size=0,this.#calculatedSize=0,typeof g==`function`&&(this.#dispose=g),typeof _==`function`&&(this.#onInsert=_),typeof v==`function`?(this.#disposeAfter=v,this.#disposed=[]):(this.#disposeAfter=void 0,this.#disposed=void 0),this.#hasDispose=!!this.#dispose,this.#hasOnInsert=!!this.#onInsert,this.#hasDisposeAfter=!!this.#disposeAfter,this.noDisposeOnSet=!!y,this.noUpdateTTL=!!b,this.noDeleteOnFetchRejection=!!E,this.allowStaleOnFetchRejection=!!O,this.allowStaleOnFetchAbort=!!k,this.ignoreFetchAbort=!!A,this.maxEntrySize!==0){if(this.#maxSize!==0&&!isPosInt(this.#maxSize))throw TypeError(`maxSize must be a positive integer if specified`);if(!isPosInt(this.maxEntrySize))throw TypeError(`maxEntrySize must be a positive integer if specified`);this.#initializeSizeTracking()}if(this.allowStale=!!h,this.noDeleteOnStaleGet=!!D,this.updateAgeOnGet=!!p,this.updateAgeOnHas=!!m,this.ttlResolution=isPosInt(s)||s===0?s:1,this.ttlAutopurge=!!u,this.ttl=a||0,this.ttl){if(!isPosInt(this.ttl))throw TypeError(`ttl must be a positive integer if specified`);this.#initializeTTLTracking()}if(this.#max===0&&this.ttl===0&&this.#maxSize===0)throw TypeError(`At least one of max, maxSize, or ttl is required`);if(!this.ttlAutopurge&&!this.#max&&!this.#maxSize){let e=`LRU_CACHE_UNBOUNDED`;shouldWarn(e)&&(warned.add(e),emitWarning(`TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.`,`UnboundedCacheWarning`,e,LRUCache))}}getRemainingTTL(e){return this.#keyMap.has(e)?1/0:0}#initializeTTLTracking(){let e=new ZeroArray(this.#max),t=new ZeroArray(this.#max);this.#ttls=e,this.#starts=t;let n=this.ttlAutopurge?Array(this.#max):void 0;this.#autopurgeTimers=n,this.#setItemTTL=(r,i,a=this.#perf.now())=>{if(t[r]=i===0?0:a,e[r]=i,n?.[r]&&(clearTimeout(n[r]),n[r]=void 0),i!==0&&n){let e=setTimeout(()=>{this.#isStale(r)&&this.#delete(this.#keyList[r],`expire`)},i+1);e.unref&&e.unref(),n[r]=e}},this.#updateItemAge=n=>{t[n]=e[n]===0?0:this.#perf.now()},this.#statusTTL=(n,a)=>{if(e[a]){let o=e[a],s=t[a];if(!o||!s)return;n.ttl=o,n.start=s,n.now=r||i(),n.remainingTTL=o-(n.now-s)}};let r=0,i=()=>{let e=this.#perf.now();if(this.ttlResolution>0){r=e;let t=setTimeout(()=>r=0,this.ttlResolution);t.unref&&t.unref()}return e};this.getRemainingTTL=n=>{let a=this.#keyMap.get(n);if(a===void 0)return 0;let o=e[a],s=t[a];return!o||!s?1/0:o-((r||i())-s)},this.#isStale=n=>{let a=t[n],o=e[n];return!!o&&!!a&&(r||i())-a>o}}#updateItemAge=()=>{};#statusTTL=()=>{};#setItemTTL=()=>{};#isStale=()=>!1;#initializeSizeTracking(){let e=new ZeroArray(this.#max);this.#calculatedSize=0,this.#sizes=e,this.#removeItemSize=t=>{this.#calculatedSize-=e[t],e[t]=0},this.#requireSize=(e,t,n,r)=>{if(this.#isBackgroundFetch(t))return 0;if(!isPosInt(n))if(r){if(typeof r!=`function`)throw TypeError(`sizeCalculation must be a function`);if(n=r(t,e),!isPosInt(n))throw TypeError(`sizeCalculation return invalid (expect positive integer)`)}else throw TypeError(`invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.`);return n},this.#addItemSize=(t,n,r)=>{if(e[t]=n,this.#maxSize){let n=this.#maxSize-e[t];for(;this.#calculatedSize>n;)this.#evict(!0)}this.#calculatedSize+=e[t],r&&(r.entrySize=n,r.totalCalculatedSize=this.#calculatedSize)}}#removeItemSize=e=>{};#addItemSize=(e,t,n)=>{};#requireSize=(e,t,n,r)=>{if(n||r)throw TypeError(`cannot set size without setting maxSize or maxEntrySize on cache`);return 0};*#indexes({allowStale:e=this.allowStale}={}){if(this.#size)for(let t=this.#tail;!(!this.#isValidIndex(t)||((e||!this.#isStale(t))&&(yield t),t===this.#head));)t=this.#prev[t]}*#rindexes({allowStale:e=this.allowStale}={}){if(this.#size)for(let t=this.#head;!(!this.#isValidIndex(t)||((e||!this.#isStale(t))&&(yield t),t===this.#tail));)t=this.#next[t]}#isValidIndex(e){return e!==void 0&&this.#keyMap.get(this.#keyList[e])===e}*entries(){for(let e of this.#indexes())this.#valList[e]!==void 0&&this.#keyList[e]!==void 0&&!this.#isBackgroundFetch(this.#valList[e])&&(yield[this.#keyList[e],this.#valList[e]])}*rentries(){for(let e of this.#rindexes())this.#valList[e]!==void 0&&this.#keyList[e]!==void 0&&!this.#isBackgroundFetch(this.#valList[e])&&(yield[this.#keyList[e],this.#valList[e]])}*keys(){for(let e of this.#indexes()){let t=this.#keyList[e];t!==void 0&&!this.#isBackgroundFetch(this.#valList[e])&&(yield t)}}*rkeys(){for(let e of this.#rindexes()){let t=this.#keyList[e];t!==void 0&&!this.#isBackgroundFetch(this.#valList[e])&&(yield t)}}*values(){for(let e of this.#indexes())this.#valList[e]!==void 0&&!this.#isBackgroundFetch(this.#valList[e])&&(yield this.#valList[e])}*rvalues(){for(let e of this.#rindexes())this.#valList[e]!==void 0&&!this.#isBackgroundFetch(this.#valList[e])&&(yield this.#valList[e])}[Symbol.iterator](){return this.entries()}[Symbol.toStringTag]=`LRUCache`;find(e,t={}){for(let n of this.#indexes()){let r=this.#valList[n],i=this.#isBackgroundFetch(r)?r.__staleWhileFetching:r;if(i!==void 0&&e(i,this.#keyList[n],this))return this.get(this.#keyList[n],t)}}forEach(e,t=this){for(let n of this.#indexes()){let r=this.#valList[n],i=this.#isBackgroundFetch(r)?r.__staleWhileFetching:r;i!==void 0&&e.call(t,i,this.#keyList[n],this)}}rforEach(e,t=this){for(let n of this.#rindexes()){let r=this.#valList[n],i=this.#isBackgroundFetch(r)?r.__staleWhileFetching:r;i!==void 0&&e.call(t,i,this.#keyList[n],this)}}purgeStale(){let e=!1;for(let t of this.#rindexes({allowStale:!0}))this.#isStale(t)&&(this.#delete(this.#keyList[t],`expire`),e=!0);return e}info(e){let t=this.#keyMap.get(e);if(t===void 0)return;let n=this.#valList[t],r=this.#isBackgroundFetch(n)?n.__staleWhileFetching:n;if(r===void 0)return;let i={value:r};if(this.#ttls&&this.#starts){let e=this.#ttls[t],n=this.#starts[t];e&&n&&(i.ttl=e-(this.#perf.now()-n),i.start=Date.now())}return this.#sizes&&(i.size=this.#sizes[t]),i}dump(){let e=[];for(let t of this.#indexes({allowStale:!0})){let n=this.#keyList[t],r=this.#valList[t],i=this.#isBackgroundFetch(r)?r.__staleWhileFetching:r;if(i===void 0||n===void 0)continue;let a={value:i};if(this.#ttls&&this.#starts){a.ttl=this.#ttls[t];let e=this.#perf.now()-this.#starts[t];a.start=Math.floor(Date.now()-e)}this.#sizes&&(a.size=this.#sizes[t]),e.unshift([n,a])}return e}load(e){this.clear();for(let[t,n]of e){if(n.start){let e=Date.now()-n.start;n.start=this.#perf.now()-e}this.set(t,n.value,n)}}set(e,t,n={}){if(t===void 0)return this.delete(e),this;let{ttl:r=this.ttl,start:i,noDisposeOnSet:a=this.noDisposeOnSet,sizeCalculation:o=this.sizeCalculation,status:s}=n,{noUpdateTTL:c=this.noUpdateTTL}=n,l=this.#requireSize(e,t,n.size||0,o);if(this.maxEntrySize&&l>this.maxEntrySize)return s&&(s.set=`miss`,s.maxEntrySizeExceeded=!0),this.#delete(e,`set`),this;let u=this.#size===0?void 0:this.#keyMap.get(e);if(u===void 0)u=this.#size===0?this.#tail:this.#free.length===0?this.#size===this.#max?this.#evict(!1):this.#size:this.#free.pop(),this.#keyList[u]=e,this.#valList[u]=t,this.#keyMap.set(e,u),this.#next[this.#tail]=u,this.#prev[u]=this.#tail,this.#tail=u,this.#size++,this.#addItemSize(u,l,s),s&&(s.set=`add`),c=!1,this.#hasOnInsert&&this.#onInsert?.(t,e,`add`);else{this.#moveToTail(u);let n=this.#valList[u];if(t!==n){if(this.#hasFetchMethod&&this.#isBackgroundFetch(n)){n.__abortController.abort(Error(`replaced`));let{__staleWhileFetching:t}=n;t!==void 0&&!a&&(this.#hasDispose&&this.#dispose?.(t,e,`set`),this.#hasDisposeAfter&&this.#disposed?.push([t,e,`set`]))}else a||(this.#hasDispose&&this.#dispose?.(n,e,`set`),this.#hasDisposeAfter&&this.#disposed?.push([n,e,`set`]));if(this.#removeItemSize(u),this.#addItemSize(u,l,s),this.#valList[u]=t,s){s.set=`replace`;let e=n&&this.#isBackgroundFetch(n)?n.__staleWhileFetching:n;e!==void 0&&(s.oldValue=e)}}else s&&(s.set=`update`);this.#hasOnInsert&&this.onInsert?.(t,e,t===n?`update`:`replace`)}if(r!==0&&!this.#ttls&&this.#initializeTTLTracking(),this.#ttls&&(c||this.#setItemTTL(u,r,i),s&&this.#statusTTL(s,u)),!a&&this.#hasDisposeAfter&&this.#disposed){let e=this.#disposed,t;for(;t=e?.shift();)this.#disposeAfter?.(...t)}return this}pop(){try{for(;this.#size;){let e=this.#valList[this.#head];if(this.#evict(!0),this.#isBackgroundFetch(e)){if(e.__staleWhileFetching)return e.__staleWhileFetching}else if(e!==void 0)return e}}finally{if(this.#hasDisposeAfter&&this.#disposed){let e=this.#disposed,t;for(;t=e?.shift();)this.#disposeAfter?.(...t)}}}#evict(e){let t=this.#head,n=this.#keyList[t],r=this.#valList[t];return this.#hasFetchMethod&&this.#isBackgroundFetch(r)?r.__abortController.abort(Error(`evicted`)):(this.#hasDispose||this.#hasDisposeAfter)&&(this.#hasDispose&&this.#dispose?.(r,n,`evict`),this.#hasDisposeAfter&&this.#disposed?.push([r,n,`evict`])),this.#removeItemSize(t),this.#autopurgeTimers?.[t]&&(clearTimeout(this.#autopurgeTimers[t]),this.#autopurgeTimers[t]=void 0),e&&(this.#keyList[t]=void 0,this.#valList[t]=void 0,this.#free.push(t)),this.#size===1?(this.#head=this.#tail=0,this.#free.length=0):this.#head=this.#next[t],this.#keyMap.delete(n),this.#size--,t}has(e,t={}){let{updateAgeOnHas:n=this.updateAgeOnHas,status:r}=t,i=this.#keyMap.get(e);if(i!==void 0){let e=this.#valList[i];if(this.#isBackgroundFetch(e)&&e.__staleWhileFetching===void 0)return!1;if(this.#isStale(i))r&&(r.has=`stale`,this.#statusTTL(r,i));else return n&&this.#updateItemAge(i),r&&(r.has=`hit`,this.#statusTTL(r,i)),!0}else r&&(r.has=`miss`);return!1}peek(e,t={}){let{allowStale:n=this.allowStale}=t,r=this.#keyMap.get(e);if(r===void 0||!n&&this.#isStale(r))return;let i=this.#valList[r];return this.#isBackgroundFetch(i)?i.__staleWhileFetching:i}#backgroundFetch(e,t,n,r){let a=t===void 0?void 0:this.#valList[t];if(this.#isBackgroundFetch(a))return a;let o=new AC,{signal:s}=n;s?.addEventListener(`abort`,()=>o.abort(s.reason),{signal:o.signal});let c={signal:o.signal,options:n,context:r},l=(r,i=!1)=>{let{aborted:a}=o.signal,s=n.ignoreFetchAbort&&r!==void 0;if(n.status&&(a&&!i?(n.status.fetchAborted=!0,n.status.fetchError=o.signal.reason,s&&(n.status.fetchAbortIgnored=!0)):n.status.fetchResolved=!0),a&&!s&&!i)return d(o.signal.reason);let l=p,u=this.#valList[t];return(u===p||s&&i&&u===void 0)&&(r===void 0?l.__staleWhileFetching===void 0?this.#delete(e,`fetch`):this.#valList[t]=l.__staleWhileFetching:(n.status&&(n.status.fetchUpdated=!0),this.set(e,r,c.options))),r},u=e=>(n.status&&(n.status.fetchRejected=!0,n.status.fetchError=e),d(e)),d=r=>{let{aborted:i}=o.signal,a=i&&n.allowStaleOnFetchAbort,s=a||n.allowStaleOnFetchRejection,c=s||n.noDeleteOnFetchRejection,l=p;if(this.#valList[t]===p&&(!c||l.__staleWhileFetching===void 0?this.#delete(e,`fetch`):a||(this.#valList[t]=l.__staleWhileFetching)),s)return n.status&&l.__staleWhileFetching!==void 0&&(n.status.returnedStale=!0),l.__staleWhileFetching;if(l.__returned===l)throw r},f=(t,r)=>{let i=this.#fetchMethod?.(e,a,c);i&&i instanceof Promise&&i.then(e=>t(e===void 0?void 0:e),r),o.signal.addEventListener(`abort`,()=>{(!n.ignoreFetchAbort||n.allowStaleOnFetchAbort)&&(t(void 0),n.allowStaleOnFetchAbort&&(t=e=>l(e,!0)))})};n.status&&(n.status.fetchDispatched=!0);let p=new Promise(f).then(l,u),m=Object.assign(p,{__abortController:o,__staleWhileFetching:a,__returned:void 0});return t===void 0?(this.set(e,m,{...c.options,status:void 0}),t=this.#keyMap.get(e)):this.#valList[t]=m,m}#isBackgroundFetch(e){if(!this.#hasFetchMethod)return!1;let t=e;return!!t&&t instanceof Promise&&t.hasOwnProperty(`__staleWhileFetching`)&&t.__abortController instanceof AC}async fetch(e,t={}){let{allowStale:n=this.allowStale,updateAgeOnGet:r=this.updateAgeOnGet,noDeleteOnStaleGet:i=this.noDeleteOnStaleGet,ttl:a=this.ttl,noDisposeOnSet:o=this.noDisposeOnSet,size:s=0,sizeCalculation:c=this.sizeCalculation,noUpdateTTL:l=this.noUpdateTTL,noDeleteOnFetchRejection:u=this.noDeleteOnFetchRejection,allowStaleOnFetchRejection:d=this.allowStaleOnFetchRejection,ignoreFetchAbort:f=this.ignoreFetchAbort,allowStaleOnFetchAbort:p=this.allowStaleOnFetchAbort,context:m,forceRefresh:h=!1,status:g,signal:_}=t;if(!this.#hasFetchMethod)return g&&(g.fetch=`get`),this.get(e,{allowStale:n,updateAgeOnGet:r,noDeleteOnStaleGet:i,status:g});let v={allowStale:n,updateAgeOnGet:r,noDeleteOnStaleGet:i,ttl:a,noDisposeOnSet:o,size:s,sizeCalculation:c,noUpdateTTL:l,noDeleteOnFetchRejection:u,allowStaleOnFetchRejection:d,allowStaleOnFetchAbort:p,ignoreFetchAbort:f,status:g,signal:_},y=this.#keyMap.get(e);if(y===void 0){g&&(g.fetch=`miss`);let t=this.#backgroundFetch(e,y,v,m);return t.__returned=t}else{let t=this.#valList[y];if(this.#isBackgroundFetch(t)){let e=n&&t.__staleWhileFetching!==void 0;return g&&(g.fetch=`inflight`,e&&(g.returnedStale=!0)),e?t.__staleWhileFetching:t.__returned=t}let i=this.#isStale(y);if(!h&&!i)return g&&(g.fetch=`hit`),this.#moveToTail(y),r&&this.#updateItemAge(y),g&&this.#statusTTL(g,y),t;let a=this.#backgroundFetch(e,y,v,m),o=a.__staleWhileFetching!==void 0&&n;return g&&(g.fetch=i?`stale`:`refresh`,o&&i&&(g.returnedStale=!0)),o?a.__staleWhileFetching:a.__returned=a}}async forceFetch(e,t={}){let n=await this.fetch(e,t);if(n===void 0)throw Error(`fetch() returned undefined`);return n}memo(e,t={}){let n=this.#memoMethod;if(!n)throw Error(`no memoMethod provided to constructor`);let{context:r,forceRefresh:i,...a}=t,o=this.get(e,a);if(!i&&o!==void 0)return o;let s=n(e,o,{options:a,context:r});return this.set(e,s,a),s}get(e,t={}){let{allowStale:n=this.allowStale,updateAgeOnGet:r=this.updateAgeOnGet,noDeleteOnStaleGet:i=this.noDeleteOnStaleGet,status:a}=t,o=this.#keyMap.get(e);if(o!==void 0){let t=this.#valList[o],s=this.#isBackgroundFetch(t);return a&&this.#statusTTL(a,o),this.#isStale(o)?(a&&(a.get=`stale`),s?(a&&n&&t.__staleWhileFetching!==void 0&&(a.returnedStale=!0),n?t.__staleWhileFetching:void 0):(i||this.#delete(e,`expire`),a&&n&&(a.returnedStale=!0),n?t:void 0)):(a&&(a.get=`hit`),s?t.__staleWhileFetching:(this.#moveToTail(o),r&&this.#updateItemAge(o),t))}else a&&(a.get=`miss`)}#connect(e,t){this.#prev[t]=e,this.#next[e]=t}#moveToTail(e){e!==this.#tail&&(e===this.#head?this.#head=this.#next[e]:this.#connect(this.#prev[e],this.#next[e]),this.#connect(this.#tail,e),this.#tail=e)}delete(e){return this.#delete(e,`delete`)}#delete(e,t){let n=!1;if(this.#size!==0){let r=this.#keyMap.get(e);if(r!==void 0)if(this.#autopurgeTimers?.[r]&&(clearTimeout(this.#autopurgeTimers?.[r]),this.#autopurgeTimers[r]=void 0),n=!0,this.#size===1)this.#clear(t);else{this.#removeItemSize(r);let n=this.#valList[r];if(this.#isBackgroundFetch(n)?n.__abortController.abort(Error(`deleted`)):(this.#hasDispose||this.#hasDisposeAfter)&&(this.#hasDispose&&this.#dispose?.(n,e,t),this.#hasDisposeAfter&&this.#disposed?.push([n,e,t])),this.#keyMap.delete(e),this.#keyList[r]=void 0,this.#valList[r]=void 0,r===this.#tail)this.#tail=this.#prev[r];else if(r===this.#head)this.#head=this.#next[r];else{let e=this.#prev[r];this.#next[e]=this.#next[r];let t=this.#next[r];this.#prev[t]=this.#prev[r]}this.#size--,this.#free.push(r)}}if(this.#hasDisposeAfter&&this.#disposed?.length){let e=this.#disposed,t;for(;t=e?.shift();)this.#disposeAfter?.(...t)}return n}clear(){return this.#clear(`delete`)}#clear(e){for(let t of this.#rindexes({allowStale:!0})){let n=this.#valList[t];if(this.#isBackgroundFetch(n))n.__abortController.abort(Error(`deleted`));else{let r=this.#keyList[t];this.#hasDispose&&this.#dispose?.(n,r,e),this.#hasDisposeAfter&&this.#disposed?.push([n,r,e])}}if(this.#keyMap.clear(),this.#valList.fill(void 0),this.#keyList.fill(void 0),this.#ttls&&this.#starts){this.#ttls.fill(0),this.#starts.fill(0);for(let e of this.#autopurgeTimers??[])e!==void 0&&clearTimeout(e);this.#autopurgeTimers?.fill(void 0)}if(this.#sizes&&this.#sizes.fill(0),this.#head=0,this.#tail=0,this.#free.length=0,this.#calculatedSize=0,this.#size=0,this.#hasDisposeAfter&&this.#disposed){let e=this.#disposed,t;for(;t=e?.shift();)this.#disposeAfter?.(...t)}}}exports.LRUCache=LRUCache;