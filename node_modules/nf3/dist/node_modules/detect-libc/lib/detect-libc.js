"use strict";const childProcess=require(`child_process`),{isLinux,getReport}=require(`./process`),{LDD_PATH,SELF_PATH,readFile,readFileSync}=require(`./filesystem`),{interpreterPath}=require(`./elf`);let cachedFamilyInterpreter,cachedFamilyFilesystem,cachedVersionFilesystem;const command=`getconf GNU_LIBC_VERSION 2>&1 || true; ldd --version 2>&1 || true`;let commandOut=``;const safeCommand=()=>commandOut||new Promise(t=>{childProcess.exec(command,(e,n)=>{commandOut=e?` `:n,t(commandOut)})}),safeCommandSync=()=>{if(!commandOut)try{commandOut=childProcess.execSync(command,{encoding:`utf8`})}catch{commandOut=` `}return commandOut},GLIBC=`glibc`,RE_GLIBC_VERSION=/LIBC[a-z0-9 \-).]*?(\d+\.\d+)/i,MUSL=`musl`,isFileMusl=e=>e.includes(`libc.musl-`)||e.includes(`ld-musl-`),familyFromReport=()=>{let e=getReport();return e.header&&e.header.glibcVersionRuntime?GLIBC:Array.isArray(e.sharedObjects)&&e.sharedObjects.some(isFileMusl)?MUSL:null},familyFromCommand=e=>{let[t,n]=e.split(/[\r\n]+/);return t&&t.includes(GLIBC)?GLIBC:n&&n.includes(MUSL)?MUSL:null},familyFromInterpreterPath=e=>{if(e){if(e.includes(`/ld-musl-`))return MUSL;if(e.includes(`/ld-linux-`))return GLIBC}return null},getFamilyFromLddContent=e=>(e=e.toString(),e.includes(`musl`)?MUSL:e.includes(`GNU C Library`)?GLIBC:null),familyFromFilesystem=async()=>{if(cachedFamilyFilesystem!==void 0)return cachedFamilyFilesystem;cachedFamilyFilesystem=null;try{cachedFamilyFilesystem=getFamilyFromLddContent(await readFile(LDD_PATH))}catch{}return cachedFamilyFilesystem},familyFromFilesystemSync=()=>{if(cachedFamilyFilesystem!==void 0)return cachedFamilyFilesystem;cachedFamilyFilesystem=null;try{cachedFamilyFilesystem=getFamilyFromLddContent(readFileSync(LDD_PATH))}catch{}return cachedFamilyFilesystem},familyFromInterpreter=async()=>{if(cachedFamilyInterpreter!==void 0)return cachedFamilyInterpreter;cachedFamilyInterpreter=null;try{cachedFamilyInterpreter=familyFromInterpreterPath(interpreterPath(await readFile(SELF_PATH)))}catch{}return cachedFamilyInterpreter},familyFromInterpreterSync=()=>{if(cachedFamilyInterpreter!==void 0)return cachedFamilyInterpreter;cachedFamilyInterpreter=null;try{cachedFamilyInterpreter=familyFromInterpreterPath(interpreterPath(readFileSync(SELF_PATH)))}catch{}return cachedFamilyInterpreter},family=async()=>{let e=null;return isLinux()&&(e=await familyFromInterpreter(),e||(e=await familyFromFilesystem(),e||=familyFromReport(),e||=familyFromCommand(await safeCommand()))),e},familySync=()=>{let e=null;return isLinux()&&(e=familyFromInterpreterSync(),e||(e=familyFromFilesystemSync(),e||=familyFromReport(),e||=familyFromCommand(safeCommandSync()))),e},isNonGlibcLinux=async()=>isLinux()&&await family()!==GLIBC,isNonGlibcLinuxSync=()=>isLinux()&&familySync()!==GLIBC,versionFromFilesystem=async()=>{if(cachedVersionFilesystem!==void 0)return cachedVersionFilesystem;cachedVersionFilesystem=null;try{let e=(await readFile(LDD_PATH)).match(RE_GLIBC_VERSION);e&&(cachedVersionFilesystem=e[1])}catch{}return cachedVersionFilesystem},versionFromFilesystemSync=()=>{if(cachedVersionFilesystem!==void 0)return cachedVersionFilesystem;cachedVersionFilesystem=null;try{let e=readFileSync(LDD_PATH).match(RE_GLIBC_VERSION);e&&(cachedVersionFilesystem=e[1])}catch{}return cachedVersionFilesystem},versionFromReport=()=>{let e=getReport();return e.header&&e.header.glibcVersionRuntime?e.header.glibcVersionRuntime:null},versionSuffix=e=>e.trim().split(/\s+/)[1],versionFromCommand=e=>{let[t,n,r]=e.split(/[\r\n]+/);return t&&t.includes(GLIBC)?versionSuffix(t):n&&r&&n.includes(MUSL)?versionSuffix(r):null},version=async()=>{let e=null;return isLinux()&&(e=await versionFromFilesystem(),e||=versionFromReport(),e||=versionFromCommand(await safeCommand())),e},versionSync=()=>{let e=null;return isLinux()&&(e=versionFromFilesystemSync(),e||=versionFromReport(),e||=versionFromCommand(safeCommandSync())),e};module.exports={GLIBC,MUSL,family,familySync,isNonGlibcLinux,isNonGlibcLinuxSync,version,versionSync};